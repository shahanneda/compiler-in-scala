/*
   Copyright 2022 Ondrej Lhotak. All rights reserved.

   Permission is granted for private study use by students registered in
   CS 241E in the Fall 2022 term.

   The contents of this file may not be published, in whole or in part,
   in print or electronic form.

   The contents of this file may be included in work submitted for CS
   241E assignments in Fall 2022. The contents of this file may not be
   submitted, in whole or in part, for credit in any other course.
*/
package cs241e.assignments

import cs241e.scanparse._
import Grammars._
import DFAs._

import scala.collection.mutable

/** Parsers for general grammars. */

object Parsing {
  /** Parses the `input` sequence of `Token`s according to the `grammar` using the Cocke-Younger-Kasami algorithm.
    * Specifically, the `kind`s of the `Token`s are considered as the terminals of the grammar, and the
    * `lexeme`s are not used for parsing but are preserved in the resulting parse tree.
    *
    * If the parse is ambiguous, returns an arbitrary one of the possible parse trees.
    *
    * If the `input` is not in the language generated by the grammar, returns `None`.
    */
  def parseCYK(grammar: Grammar, input: IndexedSeq[Token]): Option[Tree] = {
    /** The memoization table: if the string of symbols ABC derives the substring of length `length`
      * starting at position `from` of the `input`, then the entry for (Seq("A", "B", "C"), from, length)
      * contains the three parse trees of A, B, and C. If a particular string of symbols
      * does not derive a given substring of the `input`, the corresponding table entry is `None`.
      */
    val memo = mutable.Map[(Seq[String], Int, Int), Option[Seq[Tree]]]()

    /** If the string of symbols `lhs` derives the substring of length `length`
      * starting at position `from` of the `input`, returns a sequence of the parse trees for the
      * symbols in `lhs`.
      *
      * If `lhs` does not derive this substring of the input, returns `None`.
      */
    def recur(lhs: List[String], from: Int, length: Int): Option[Seq[Tree]] = {
//      println("doing ", lhs, from, length, input.toSeq.splitAt(from)._2.take(length))
      if(length < 0){
        return None
      }
      if(memo.contains(lhs, from, length)){
        val l = memo.get(lhs, from, length).getOrElse(sys.error(("Invalid memo")))
        return l
      }
      memo.addOne((lhs, from, length), None)

      if(lhs.isEmpty){
        if(length == 0) {
//          println("found empty")
          memo((lhs, from, length)) = Option(Seq())
          return Option(Seq())
        }
        return None
      }
      else if(lhs.length == 1){
        val a = lhs.head;
        if(grammar.terminals.contains(a)){
//          println("found terminal ")
          if(length != 1 || input(from).kind != a){
            return None;
          }

          val out = Option(Seq(new Tree(input(from))));
          memo((lhs, from, length)) = out
          return out;
        }
        else if(grammar.productionsExpanding.contains(a)){
          for(prod <- grammar.productionsExpanding(a)){
            val restOut = recur(prod.rhs.toList, from, length);
            if(restOut.isDefined){
              var out: Option[Seq[Tree]] = None;
              //if(restOut.getOrElse(sys.error("")).isEmpty){
               // out = Option(restOut.getOrElse(sys.error("")));
              //}
              //else{
                out = Option(Seq(new Tree(Token(a), restOut.getOrElse(sys.error("")))))
              //}
//              println("restOut is", restOut.getOrElse(sys.error("")).isEmpty)
//              println("returning from trying all productison case ", out)
              memo((lhs, from, length)) = out
              return out
            }
          }
          None
        }else{
          memo((lhs, from, length)) = None;
          return None
        }
      }else{
//        println("have multiple left over")
        if(grammar.terminals.contains(lhs.head)){
//          println("first is terminal")
          val token = input(from)
          if( token.kind == lhs.head){
            val parseRest = recur(lhs.tail, from + 1, length - 1)
            if(parseRest.isDefined){
              val out = Option(Seq(new Tree(input(from))) ++ parseRest.getOrElse(sys.error("")))
//              println("retuining from first is terminal case", out);
              memo((lhs, from, length)) = out;
              return out
            }
          }
          return None
        }else if(grammar.productionsExpanding.contains(lhs.head)){
//          println(" in split case ")
          for(firstLength <- 0 until length ){
            val secondLength = length - firstLength
            val secondFrom = from + firstLength
            val parseA = recur(List(lhs.head), from, firstLength)

            if(parseA.isDefined){
//              println("found first parse", parseA.getOrElse(sys.error("")))
              val parseB = recur(lhs.tail, secondFrom, secondLength)
              if(parseB.isDefined){
//                println("found second parse", parseB.getOrElse(sys.error("")))
                val out = Option(parseA.get ++ parseB.get)
                memo((lhs, from, length)) = out
                return out
              }
            }
          }
          return None
        }else{
//          println("exiting")
          None;
        }
      }
    }

    val out = recur(List(grammar.start), 0, input.size)
    out.map(_.head)
  }

  /** Parses the `input` string of terminals according to the `grammar` using Earley's algorithm.
    * Returns `true` if the `input` string is in the language generated by the `grammar`,
    * `false` otherwise.
    *
    * Note: Optional, for bonus only.
    */
  def parseEarley(grammar: Grammar, input: IndexedSeq[String]): Boolean = { ??? }
}
